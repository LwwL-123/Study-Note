### Golang空结构体作用

答：节省内存

1. map。
   value是空结构体，构造集合。

2. 通道。
   只传递信号，不传递数据。

3. 切片。
   不管切片多长，都不会占用空间。

4. 仅包含方法的结构体。
   不用指针，节约空间。

5. 最后零字段。
   final zero field：结构体里的最后一个属性如果是空结构体，会当成1个字节处理。如果结构体嵌套的全是空结构体，还是0个字节。



### golang map 判断key是否存在

```go
if _, ok := map[key]; ok {
    // 存在
}
 
if _, ok := map[key]; !ok {
    // 不存在
}
```



### 各包init的执行顺序

- 如果一个包导入了其他包，则首先初始化导入的包。
- 然后初始化当前包的常量。
- 接下来初始化当前包的变量。
- 最后，调用当前包的 init() 函数。

![在这里插入图片描述](https://gitee.com/lzw657434763/pictures/raw/master/Blog/20211223163615.png)

```
import --> const --> var --> init()
```

- 一个包可以有多个 init 函数 (在单个文件中或分布在多个文件中)，并且按照它们呈现给编译器的顺序被调用。

- 一个包将只初始化一次，即使它是从多个包导入的。



###  go语言的时候垃圾回收，写代码的时候如何减少小对象分配 

小对象在堆上频繁地申请释放，会造成内存碎片（有的叫空洞），导致分配大的对象时无法申请到连续的内存空间，一般建议是采用内存池。Go runtime底层也采用内存池，但每个span大小为4k，同时维护一个cache。cache有一个0到n的list数组，list数组的每个单元挂载的是一个链表，链表的每个节点就是一块可用的内存，同一链表中的所有节点内存块都是大小相等的；但是不同链表的内存大小是不等的，也就是说list数组的一个单元存储的是一类固定大小的内存块，不同单元里存储的内存块大小是不等的。这就说明cache缓存的是不同类大小的内存对象，当然想申请的内存大小最接近于哪类缓存内存块时，就分配哪类内存块。当cache不够再向spanalloc中分配。

建议：小对象合并成结构体一次分配，示意如下：

```go
for k, v := range m {
    k, v := k, v // copy for capturing by the goroutine
    go func() {
        // using k & v
    }()
}
```

替换为：

```go
for k, v := range m {
    x := struct {k , v string} {k, v} // copy for capturing by the goroutine
    go func() {
        // using x.k & x.v
    }()
}
```
